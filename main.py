import collections
import os
import string

import nltk

import settings
from builders.ns_builder import NSBuilder
from builders.qs_builder import QSBuilder
from learning.classifiers.qs_classifier import QSClassifier
from learning.classifiers.sentiment_classifier import SNClassifier
from learning.sequencer.input_sequencer import InputSequencer
from network.server import NetworkServer
from semantics.object_node import ObjectNode
from semantics.query_handler_two import QueryHandler

from semantics.semantic_network import SemanticNetwork


def clean_start():
    output_directory = settings.DATA_OUT
    for out_file in os.listdir(output_directory):
        out_file_path = os.path.join(output_directory, out_file)
        os.unlink(out_file_path)

if __name__ == "__main__":
    # Erase all files in the out directory
    #clean_start()

    """
        The SNClassifier uses a Naive Bayes classifier to distinguish between a positive and
        a negative simple sentence. The SNClassifier uses a handcrafted corpus found in the
        data/sensets folder.
    """
    input("\nSNClassifier...")
    sn_classifier = SNClassifier()
    sn_classifier.train()

    """
        Will load from a pickle if one exists.
        The NSBuilder builds XML network sets to train on. The output of this operation
        can be found in the out/network_set.xml file.
    """
    input("\nNSBuilder...")
    ns_builder = NSBuilder(sn_classifier).load()
    ns_builder.create_standard_set()
    #
    # """
    #     The InputSequencer trains on the network set created by the previous operation.
    #     This operation uses a genetic algorithm in order to create function sequences that
    #     are used to parse new data.
    # """
    input("\nInputSequencer...")
    input_sequencer = InputSequencer().load()
    input_sequencer.train()

    """
        The QSBuilder builds question/statement lists to train on.
        This operation uses a presidential inaugural address corpus in conjunction with
        files pulled from NLP competition data sets.
    """
    input("\nQSBuilder...")
    qs_builder = QSBuilder()
    qs_builder.create_standard_set()

    """
        The QSClassifier uses a Naive Bayes classifier to distinguish between a question
        and a statement. The QSClassifier trains on the data generated by the previous operation.
    """
    input("\nQSClassifier...")
    qs_classifier = QSClassifier()
    qs_classifier.train()

    input("\nSemanticNetwork...")
    semantic_network = SemanticNetwork(sn_classifier)
    corpora = os.path.join(settings.DATA_CORPUS, 'mammal_corpora.txt')
    with open(corpora) as file:
        for line in file:
            semantic_network.add_node(input_sequencer.parse_to_node(line))
    semantic_network.print()

    input("\nQueryHandler...")
    query_handler = QueryHandler(semantic_network, sn_classifier, debug=True)
    #
    # network_server = NetworkServer()
    # network_server.listen()
    # while True:
    #     benson_query = network_server.get_data()
    #     if "question" in qs_classifier.classify_text(benson_query):
    #         network_server.send_data(query_handler.query(benson_query))
    #     else:
    #         semantic_network.add_node(input_sequencer.parse_to_node(benson_query))
    #         network_server.send_data("Thanks for the new information")
    #     network_server.send_data(query_handler.query(benson_query))

    for i in range(10):
        query = input("Enter a question or statement: ")

        # if "question" in qs_classifier.classify_text(query):
        print("You asked me a question")
        print(query_handler.query(query))
        # else:
        #     print("You gave me new information")
        #     semantic_network.add_node(input_sequencer.parse_to_node(query))